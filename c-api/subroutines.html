

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Subroutines (C API) &mdash; libmipflooding  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=66b59bf7" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=4db067b0" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../_static/doctools.js?v=9a2dae69"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/break-words.js?v=8491e5ed"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Helper functions" href="helper-functions.html" />
    <link rel="prev" title="Core functions (C API)" href="core-functions.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            libmipflooding
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../getting-started.html">Getting started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../getting-started.html#input-data-and-processing-options">Input data and processing options</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../mip-flooding.html">Mip-flooding an image</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../mip-flooding.html#using-the-flood-image-function">Using the flood_image() function</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mip-flooding.html#executing-the-subroutines-manually">Executing the subroutines manually</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../generating-mip-maps.html">Generating mip maps</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../generating-mip-maps.html#generate-mips">generate_mips()</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generating-mip-maps.html#composite-mips">composite_mips()</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../cpp-api/index.html">C++ API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../cpp-api/core-functions.html">Core functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../cpp-api/core-functions.html#_CPPv4I00EN14libmipflooding13generate_mipsE10LMF_STATUSP6ImageTK13uint_fast16_tK13uint_fast16_tK12uint_fast8_tPK5MaskTPPfPP7uint8_tKfKbKbK7uint8_tKbK12uint_fast8_t"><code class="docutils literal notranslate"><span class="pre">generate_mips()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../cpp-api/core-functions.html#_CPPv4N14libmipflooding14composite_mipsEPPfPPK7uint8_tK13uint_fast16_tK13uint_fast16_tK12uint_fast8_tK7uint8_tK12uint_fast8_t"><code class="docutils literal notranslate"><span class="pre">composite_mips()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../cpp-api/core-functions.html#_CPPv4I00EN14libmipflooding11flood_imageE10LMF_STATUSP6ImageTK13uint_fast16_tK13uint_fast16_tK12uint_fast8_tPK5MaskTKfKbKbK7uint8_tKbK12uint_fast8_t"><code class="docutils literal notranslate"><span class="pre">flood_image()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../cpp-api/subroutines.html">Subroutines (C++ API)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../cpp-api/subroutines.html#_CPPv4I00EN14libmipflooding31convert_and_scale_down_weightedEvK13uint_fast16_tK13uint_fast16_tK12uint_fast8_tPK6InputTPK10InputMaskTPfP7uint8_tKfKbKbK7uint8_tKbK13uint_fast16_t"><code class="docutils literal notranslate"><span class="pre">convert_and_scale_down_weighted()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../cpp-api/subroutines.html#_CPPv4I00EN14libmipflooding40convert_and_scale_down_weighted_threadedEvK13uint_fast16_tK13uint_fast16_tK12uint_fast8_tPK6InputTPK10InputMaskTPfP7uint8_tKfKbKbK7uint8_tKbK12uint_fast8_t"><code class="docutils literal notranslate"><span class="pre">convert_and_scale_down_weighted_threaded()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../cpp-api/subroutines.html#_CPPv4N14libmipflooding19scale_down_weightedEK13uint_fast16_tK13uint_fast16_tK12uint_fast8_tPKfPK7uint8_tPfP7uint8_tKbK7uint8_tKbK13uint_fast16_t"><code class="docutils literal notranslate"><span class="pre">scale_down_weighted()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../cpp-api/subroutines.html#_CPPv4N14libmipflooding28scale_down_weighted_threadedEK13uint_fast16_tK13uint_fast16_tK12uint_fast8_tPKfPK7uint8_tPfP7uint8_tKbK7uint8_tKbK12uint_fast8_t"><code class="docutils literal notranslate"><span class="pre">scale_down_weighted_threaded()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../cpp-api/subroutines.html#_CPPv4N14libmipflooding12composite_upEK13uint_fast16_tK13uint_fast16_tK12uint_fast8_tPKfPfPK7uint8_tK7uint8_tK13uint_fast16_t"><code class="docutils literal notranslate"><span class="pre">composite_up()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../cpp-api/subroutines.html#_CPPv4N14libmipflooding21composite_up_threadedEK13uint_fast16_tK13uint_fast16_tK12uint_fast8_tPKfPfPK7uint8_tK7uint8_tK12uint_fast8_t"><code class="docutils literal notranslate"><span class="pre">composite_up_threaded()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../cpp-api/subroutines.html#_CPPv4I00EN14libmipflooding27final_composite_and_convertEvK13uint_fast16_tK13uint_fast16_tK12uint_fast8_tPKfP7OutputTPK5MaskTKfKbK7uint8_tK13uint_fast16_t"><code class="docutils literal notranslate"><span class="pre">final_composite_and_convert()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../cpp-api/subroutines.html#_CPPv4I00EN14libmipflooding36final_composite_and_convert_threadedEvK13uint_fast16_tK13uint_fast16_tK12uint_fast8_tPKfP7OutputTPK5MaskTKfKbK7uint8_tK12uint_fast8_t"><code class="docutils literal notranslate"><span class="pre">final_composite_and_convert_threaded()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../cpp-api/helper-functions.html">Helper functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../cpp-api/helper-functions.html#_CPPv4I0EN14libmipflooding15convert_to_typeEvK13uint_fast16_tK13uint_fast16_tK12uint_fast8_tPKfP7OutputTKbK7uint8_tK13uint_fast16_t"><code class="docutils literal notranslate"><span class="pre">convert_to_type()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../cpp-api/helper-functions.html#_CPPv4I0EN14libmipflooding24convert_to_type_threadedEvK13uint_fast16_tK13uint_fast16_tK12uint_fast8_tPKfP7OutputTKbK7uint8_tK7uint8_t"><code class="docutils literal notranslate"><span class="pre">convert_to_type_threaded()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../cpp-api/helper-functions.html#_CPPv4N14libmipflooding13get_mip_countEK13uint_fast16_tK13uint_fast16_t"><code class="docutils literal notranslate"><span class="pre">get_mip_count()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../cpp-api/helper-functions.html#_CPPv4N14libmipflooding23channel_mask_from_arrayEPKbK12uint_fast8_t"><code class="docutils literal notranslate"><span class="pre">channel_mask_from_array()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../cpp-api/helper-functions.html#_CPPv4N14libmipflooding16free_mips_memoryEK12uint_fast8_tPPfPP7uint8_t"><code class="docutils literal notranslate"><span class="pre">free_mips_memory()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../cpp-api/lmf-status.html">LMF_STATUS</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">C API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="core-functions.html">Core functions (C API)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="core-functions.html#_CPPv4N16libmipflooding_c13generate_mipsEPvK13LMF_DATA_TYPEK8uint16_tK8uint16_tK7uint8_tPK7uint8_tPPfPP7uint8_tKfKbKbK7uint8_tKbK7uint8_t"><code class="docutils literal notranslate"><span class="pre">generate_mips()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core-functions.html#_CPPv4N16libmipflooding_c14composite_mipsEPPfPPK7uint8_tK8uint16_tK8uint16_tK7uint8_tK7uint8_tK7uint8_t"><code class="docutils literal notranslate"><span class="pre">composite_mips()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="core-functions.html#_CPPv4N16libmipflooding_c11flood_imageEPvK13LMF_DATA_TYPEK8uint16_tK8uint16_tK7uint8_tPKvK13LMF_DATA_TYPEKfKbKbK7uint8_tKbK7uint8_t"><code class="docutils literal notranslate"><span class="pre">flood_image()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Subroutines (C API)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#_CPPv4N16libmipflooding_c31convert_and_scale_down_weightedEK8uint16_tK8uint16_tK7uint8_tPKvK13LMF_DATA_TYPEPKvK13LMF_DATA_TYPEPfP7uint8_tKfKbKbK7uint8_tKbK8uint16_t"><code class="docutils literal notranslate"><span class="pre">convert_and_scale_down_weighted()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#_CPPv4N16libmipflooding_c40convert_and_scale_down_weighted_threadedEK8uint16_tK8uint16_tK7uint8_tPKvK13LMF_DATA_TYPEPKvK13LMF_DATA_TYPEPfP7uint8_tKfKbKbK7uint8_tKbK7uint8_t"><code class="docutils literal notranslate"><span class="pre">convert_and_scale_down_weighted_threaded()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#_CPPv4N16libmipflooding_c19scale_down_weightedEK8uint16_tK8uint16_tK7uint8_tPKfPK7uint8_tPfP7uint8_tKbK7uint8_tKbK8uint16_t"><code class="docutils literal notranslate"><span class="pre">scale_down_weighted()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#_CPPv4N16libmipflooding_c28scale_down_weighted_threadedEK8uint16_tK8uint16_tK7uint8_tPKfPK7uint8_tPfP7uint8_tKbK7uint8_tKbK7uint8_t"><code class="docutils literal notranslate"><span class="pre">scale_down_weighted_threaded()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#_CPPv4N16libmipflooding_c12composite_upEK8uint16_tK8uint16_tK7uint8_tPKfPfPK7uint8_tK7uint8_tK8uint16_t"><code class="docutils literal notranslate"><span class="pre">composite_up()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#_CPPv4N16libmipflooding_c21composite_up_threadedEK8uint16_tK8uint16_tK7uint8_tPKfPfPK7uint8_tK7uint8_tK7uint8_t"><code class="docutils literal notranslate"><span class="pre">composite_up_threaded()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#_CPPv4N16libmipflooding_c27final_composite_and_convertEK8uint16_tK8uint16_tK7uint8_tPKfPvK13LMF_DATA_TYPEPKvK13LMF_DATA_TYPEKfKbK7uint8_tK8uint16_t"><code class="docutils literal notranslate"><span class="pre">final_composite_and_convert()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#_CPPv4N16libmipflooding_c36final_composite_and_convert_threadedEK8uint16_tK8uint16_tK7uint8_tPKfPvK13LMF_DATA_TYPEPKvK13LMF_DATA_TYPEKfKbK7uint8_tK7uint8_t"><code class="docutils literal notranslate"><span class="pre">final_composite_and_convert_threaded()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="helper-functions.html">Helper functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="helper-functions.html#_CPPv4N16libmipflooding_c15convert_to_typeEK13uint_fast16_tK13uint_fast16_tK12uint_fast8_tPKfPvK13LMF_DATA_TYPEKbK7uint8_tK13uint_fast16_t"><code class="docutils literal notranslate"><span class="pre">convert_to_type()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="helper-functions.html#_CPPv4N16libmipflooding_c24convert_to_type_threadedEK13uint_fast16_tK13uint_fast16_tK12uint_fast8_tPKfPvK13LMF_DATA_TYPEKbK7uint8_tK7uint8_t"><code class="docutils literal notranslate"><span class="pre">convert_to_type_threaded()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="helper-functions.html#_CPPv4N16libmipflooding_c13get_mip_countEK8uint16_tK8uint16_t"><code class="docutils literal notranslate"><span class="pre">get_mip_count()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="helper-functions.html#_CPPv4N16libmipflooding_c23channel_mask_from_arrayEPKbK7uint8_t"><code class="docutils literal notranslate"><span class="pre">channel_mask_from_array()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="helper-functions.html#_CPPv4N16libmipflooding_c16free_mips_memoryEK12uint_fast8_tPPfPP7uint8_t"><code class="docutils literal notranslate"><span class="pre">free_mips_memory()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="data-type.html">LMF_DATA_TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="lmf-status.html">LMF_STATUS</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../python/index.html">Python wrapper</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../python/functions.html">Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../python/functions.html#libmipflooding.flood_image"><code class="docutils literal notranslate"><span class="pre">flood_image()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../python/functions.html#libmipflooding.generate_mips"><code class="docutils literal notranslate"><span class="pre">generate_mips()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../python/functions.html#libmipflooding.get_channel_mask"><code class="docutils literal notranslate"><span class="pre">get_channel_mask()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../python/functions.html#libmipflooding.get_mip_count"><code class="docutils literal notranslate"><span class="pre">get_mip_count()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">libmipflooding</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">C API</a></li>
      <li class="breadcrumb-item active">Subroutines (C API)</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/c-api/subroutines.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="subroutines-c-api">
<h1>Subroutines (C API)<a class="headerlink" href="#subroutines-c-api" title="Link to this heading"></a></h1>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N16libmipflooding_c31convert_and_scale_down_weightedEK8uint16_tK8uint16_tK7uint8_tPKvK13LMF_DATA_TYPEPKvK13LMF_DATA_TYPEPfP7uint8_tKfKbKbK7uint8_tKbK8uint16_t">
<span id="_CPPv3N16libmipflooding_c31convert_and_scale_down_weightedEK8uint16_tK8uint16_tK7uint8_tPKvK13LMF_DATA_TYPEPKvK13LMF_DATA_TYPEPfP7uint8_tKfKbKbK7uint8_tKbK8uint16_t"></span><span id="_CPPv2N16libmipflooding_c31convert_and_scale_down_weightedEK8uint16_tK8uint16_tK7uint8_tPKvK13LMF_DATA_TYPEPKvK13LMF_DATA_TYPEPfP7uint8_tKfKbKbK7uint8_tKbK8uint16_t"></span><span id="libmipflooding_c::convert_and_scale_down_weighted__uint16_tC.uint16_tC.uint8_tC.voidCP.LMF_DATA_TYPEC.voidCP.LMF_DATA_TYPEC.floatP.uint8_tP.floatC.bC.bC.uint8_tC.bC.uint16_tC"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="pre">convert</span><span class="pre">_and</span><span class="pre">_scale</span><span class="pre">_down</span><span class="pre">_weighted()</span></span><a class="headerlink reference internal" href="#_CPPv4N16libmipflooding_c31convert_and_scale_down_weightedEK8uint16_tK8uint16_tK7uint8_tPKvK13LMF_DATA_TYPEPKvK13LMF_DATA_TYPEPfP7uint8_tKfKbKbK7uint8_tKbK8uint16_t" title="libmipflooding_c::convert_and_scale_down_weighted"><span class="pre"></span></a></dt>
<dd><p class="brief">Pre-process and scale down input image. </p>
<p>Converts the input image to float, and the input mask to binary (stored as uint8_t). If no input mask is provided (nullptr), the last color channel of the input image is used as the mask (e.g. “A” for an RGBA image).</p>
<p>Image and mask are scaled down to half their size, using the mask-weighted average for the image, and a threshold for the mask (i.e. if any of the 4 mask pixels to be scaled is 1, the scaled pixel becomes 1).</p>
<p>The input mask is initially processed using the coverage_threshold parameter, which defaults to 0.999f (anything above 0.999f becomes 1, all other values become 0).</p>
<p>The last image channel can optionally be scaled unweighted (regular box filtering). This can be useful when e.g. the alpha channel should reflect the average opacity, as opposed to becoming 1.0f through weighted scaling in cases where the alpha channel is identical to the coverage mask.</p>
<dl class="parameters field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="parameter-description field-list simple">
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint16_t</span><span class="w"> </span><span class="n sig-param">output_width</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Output image width in pixels (must be power of 2) </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint16_t</span><span class="w"> </span><span class="n sig-param">output_height_or_end_row</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Output image height in pixels (must be power of 2), or end row for partial processing </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint8_t</span><span class="w"> </span><span class="n sig-param">channel_stride</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Number of total channels in image data </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">input_image</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Pointer to input image, void* </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><a class="reference internal" href="data-type.html#_CPPv4N16libmipflooding_c13LMF_DATA_TYPEE" title="libmipflooding_c::LMF_DATA_TYPE"><span class="n">LMF_DATA_TYPE</span></a><span class="w"> </span><span class="n sig-param">input_data_type</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Input image type as LMF_DATA_TYPE enum value </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">input_mask</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>(optional) Pointer to input mask, void* or nullptr </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><a class="reference internal" href="data-type.html#_CPPv4N16libmipflooding_c13LMF_DATA_TYPEE" title="libmipflooding_c::LMF_DATA_TYPE"><span class="n">LMF_DATA_TYPE</span></a><span class="w"> </span><span class="n sig-param">input_mask_data_type</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Input mask data type as LMF_DATA_TYPE enum value, ignored when input mask pointer is nullptr </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="kt float">float</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">output_image</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Pointer to pre-allocated output image, float* </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="kt int">uint8_t</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">output_mask</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Pointer to pre-allocated output mask, uint8_t* </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt float">float</span><span class="w"> </span><span class="n sig-param">coverage_threshold</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0.999f</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>(optional) Threshold to use for binarizing the input mask. Defaults to 0.999f. </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt bool">bool</span><span class="w"> </span><span class="n sig-param">convert_srgb_to_linear</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">false</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>(optional) Convert sRGB to linear for correct scaling of sRGB textures? </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt bool">bool</span><span class="w"> </span><span class="n sig-param">is_normal_map</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">false</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>(optional) Perform processing for normal maps. Will re-normalize vectors to unit length at the moment, Slerp is planned. </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint8_t</span><span class="w"> </span><span class="n sig-param">channel_mask</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>(optional) Bit mask of channels to process, 0 = all channels. You can use <a class="reference internal" href="helper-functions.html#_CPPv4N16libmipflooding_c23channel_mask_from_arrayEPKbK7uint8_t" title="libmipflooding_c::channel_mask_from_array">channel_mask_from_array()</a> to generate a mask from an array of booleans. </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt bool">bool</span><span class="w"> </span><span class="n sig-param">scale_alpha_unweighted</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">false</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>(optional) Scale the last channel without coverage weighting? i.e. regular box filtering </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint16_t</span><span class="w"> </span><span class="n sig-param">start_row</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span></p>
<span class="colon">:</span></dt>
<dd class="field-odd"><p>(optional) Start row for partial processing </p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N16libmipflooding_c40convert_and_scale_down_weighted_threadedEK8uint16_tK8uint16_tK7uint8_tPKvK13LMF_DATA_TYPEPKvK13LMF_DATA_TYPEPfP7uint8_tKfKbKbK7uint8_tKbK7uint8_t">
<span id="_CPPv3N16libmipflooding_c40convert_and_scale_down_weighted_threadedEK8uint16_tK8uint16_tK7uint8_tPKvK13LMF_DATA_TYPEPKvK13LMF_DATA_TYPEPfP7uint8_tKfKbKbK7uint8_tKbK7uint8_t"></span><span id="_CPPv2N16libmipflooding_c40convert_and_scale_down_weighted_threadedEK8uint16_tK8uint16_tK7uint8_tPKvK13LMF_DATA_TYPEPKvK13LMF_DATA_TYPEPfP7uint8_tKfKbKbK7uint8_tKbK7uint8_t"></span><span id="libmipflooding_c::convert_and_scale_down_weighted_threaded__uint16_tC.uint16_tC.uint8_tC.voidCP.LMF_DATA_TYPEC.voidCP.LMF_DATA_TYPEC.floatP.uint8_tP.floatC.bC.bC.uint8_tC.bC.uint8_tC"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="pre">convert</span><span class="pre">_and</span><span class="pre">_scale</span><span class="pre">_down</span><span class="pre">_weighted</span><span class="pre">_threaded()</span></span><a class="headerlink reference internal" href="#_CPPv4N16libmipflooding_c40convert_and_scale_down_weighted_threadedEK8uint16_tK8uint16_tK7uint8_tPKvK13LMF_DATA_TYPEPKvK13LMF_DATA_TYPEPfP7uint8_tKfKbKbK7uint8_tKbK7uint8_t" title="libmipflooding_c::convert_and_scale_down_weighted_threaded"><span class="pre"></span></a></dt>
<dd><p class="brief">Pre-process and scale down input image (threaded version) </p>
<p>Converts the input image to float, and the input mask to binary (stored as uint8_t). If no input mask is provided (nullptr), the last color channel of the input image is used as the mask (e.g. “A” for an RGBA image).</p>
<p>Image and mask are scaled down to half their size, using the mask-weighted average for the image, and a threshold for the mask (i.e. if any of the 4 mask pixels to be scaled is 1, the scaled pixel becomes 1).</p>
<p>The input mask is initially processed using the coverage_threshold parameter, which defaults to 0.999f (anything above 0.999f becomes 1, all other values become 0).</p>
<p>The last image channel can optionally be scaled unweighted (regular box filtering). This can be useful when e.g. the alpha channel should reflect the average opacity, as opposed to becoming 1.0f through weighted scaling in cases where the alpha channel is identical to the coverage mask.</p>
<dl class="parameters field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="parameter-description field-list simple">
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint16_t</span><span class="w"> </span><span class="n sig-param">output_width</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Output image width in pixels (must be power of 2) </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint16_t</span><span class="w"> </span><span class="n sig-param">output_height</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Output image height in pixels (must be power of 2) </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint8_t</span><span class="w"> </span><span class="n sig-param">channel_stride</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Number of total channels in image data </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">input_image</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Pointer to input image, void* </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><a class="reference internal" href="data-type.html#_CPPv4N16libmipflooding_c13LMF_DATA_TYPEE" title="libmipflooding_c::LMF_DATA_TYPE"><span class="n">LMF_DATA_TYPE</span></a><span class="w"> </span><span class="n sig-param">input_data_type</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Input image type as LMF_DATA_TYPE enum value </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">input_mask</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>(optional) Pointer to input mask, void* or nullptr </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><a class="reference internal" href="data-type.html#_CPPv4N16libmipflooding_c13LMF_DATA_TYPEE" title="libmipflooding_c::LMF_DATA_TYPE"><span class="n">LMF_DATA_TYPE</span></a><span class="w"> </span><span class="n sig-param">input_mask_data_type</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Input mask data type as LMF_DATA_TYPE enum value, ignored when input mask pointer is nullptr </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="kt float">float</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">output_image</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Pointer to pre-allocated output image, float* </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="kt int">uint8_t</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">output_mask</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Pointer to pre-allocated output mask, uint8_t* </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt float">float</span><span class="w"> </span><span class="n sig-param">coverage_threshold</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0.999f</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>(optional) Threshold to use for binarizing the input mask. Defaults to 0.999f. </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt bool">bool</span><span class="w"> </span><span class="n sig-param">convert_srgb_to_linear</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">false</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>(optional) Convert sRGB to linear for correct scaling of sRGB textures? </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt bool">bool</span><span class="w"> </span><span class="n sig-param">is_normal_map</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">false</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>(optional) Perform processing for normal maps. Will re-normalize vectors to unit length at the moment, Slerp is planned. </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint8_t</span><span class="w"> </span><span class="n sig-param">channel_mask</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>(optional) Bit mask of channels to process, 0 = all channels. You can use <a class="reference internal" href="helper-functions.html#_CPPv4N16libmipflooding_c23channel_mask_from_arrayEPKbK7uint8_t" title="libmipflooding_c::channel_mask_from_array">channel_mask_from_array()</a> to generate a mask from an array of booleans. </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt bool">bool</span><span class="w"> </span><span class="n sig-param">scale_alpha_unweighted</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">false</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>(optional) Scale the last channel without coverage weighting? i.e. regular box filtering </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint8_t</span><span class="w"> </span><span class="n sig-param">max_threads</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span></p>
<span class="colon">:</span></dt>
<dd class="field-odd"><p>(optional) Number of threads to use. 0 = auto (half of available threads, which amounts to number of hardware cores for machines with SMT/HyperThreading) </p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N16libmipflooding_c19scale_down_weightedEK8uint16_tK8uint16_tK7uint8_tPKfPK7uint8_tPfP7uint8_tKbK7uint8_tKbK8uint16_t">
<span id="_CPPv3N16libmipflooding_c19scale_down_weightedEK8uint16_tK8uint16_tK7uint8_tPKfPK7uint8_tPfP7uint8_tKbK7uint8_tKbK8uint16_t"></span><span id="_CPPv2N16libmipflooding_c19scale_down_weightedEK8uint16_tK8uint16_tK7uint8_tPKfPK7uint8_tPfP7uint8_tKbK7uint8_tKbK8uint16_t"></span><span id="libmipflooding_c::scale_down_weighted__uint16_tC.uint16_tC.uint8_tC.floatCP.uint8_tCP.floatP.uint8_tP.bC.uint8_tC.bC.uint16_tC"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="pre">scale</span><span class="pre">_down</span><span class="pre">_weighted()</span></span><a class="headerlink reference internal" href="#_CPPv4N16libmipflooding_c19scale_down_weightedEK8uint16_tK8uint16_tK7uint8_tPKfPK7uint8_tPfP7uint8_tKbK7uint8_tKbK8uint16_t" title="libmipflooding_c::scale_down_weighted"><span class="pre"></span></a></dt>
<dd><p class="brief">Scale down mip level. </p>
<p>Input mip level and mask are scaled down to half their size, using the mask-weighted average for the mip, and a threshold for the mask (i.e. if any of the 4 mask pixels to be scaled is 1, the scaled pixel becomes 1).</p>
<p>The last image channel can optionally be scaled unweighted (regular box filtering). This can be useful when e.g. the alpha channel should reflect the average opacity, as opposed to becoming 1.0f through weighted scaling in cases where the alpha channel is identical to the coverage mask.</p>
<p>Use this function in a loop after <a class="reference internal" href="#_CPPv4N16libmipflooding_c31convert_and_scale_down_weightedEK8uint16_tK8uint16_tK7uint8_tPKvK13LMF_DATA_TYPEPKvK13LMF_DATA_TYPEPfP7uint8_tKfKbKbK7uint8_tKbK8uint16_t" title="libmipflooding_c::convert_and_scale_down_weighted">convert_and_scale_down_weighted()</a> to generate the remaining mip levels.</p>
<dl class="parameters field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="parameter-description field-list simple">
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint16_t</span><span class="w"> </span><span class="n sig-param">output_width</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Output mip level width in pixels (must be power of 2) </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint16_t</span><span class="w"> </span><span class="n sig-param">output_height_or_end_row</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Output mip level height in pixels (must be power of 2), or end row for partial processing </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint8_t</span><span class="w"> </span><span class="n sig-param">channel_stride</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Number of total channels in image data </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt float">float</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">input_image</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Pointer to input mip level, float* </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint8_t</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">input_mask</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Pointer to input mip mask, uint8_t* </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="kt float">float</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">output_image</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Pointer to pre-allocated output mip level, float* </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="kt int">uint8_t</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">output_mask</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Pointer to pre-allocated output mip mask, uint8_t* </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt bool">bool</span><span class="w"> </span><span class="n sig-param">is_normal_map</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>(optional) Perform processing for normal maps. Will re-normalize vectors to unit length at the moment, Slerp is planned. </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint8_t</span><span class="w"> </span><span class="n sig-param">channel_mask</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>(optional) Bit mask of channels to process, 0 = all channels. You can use <a class="reference internal" href="helper-functions.html#_CPPv4N16libmipflooding_c23channel_mask_from_arrayEPKbK7uint8_t" title="libmipflooding_c::channel_mask_from_array">channel_mask_from_array()</a> to generate a mask from an array of booleans. </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt bool">bool</span><span class="w"> </span><span class="n sig-param">scale_alpha_unweighted</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">false</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>(optional) Scale the last channel without coverage weighting? i.e. regular box filtering </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint16_t</span><span class="w"> </span><span class="n sig-param">start_row</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span></p>
<span class="colon">:</span></dt>
<dd class="field-odd"><p>(optional) Start row for partial processing </p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N16libmipflooding_c28scale_down_weighted_threadedEK8uint16_tK8uint16_tK7uint8_tPKfPK7uint8_tPfP7uint8_tKbK7uint8_tKbK7uint8_t">
<span id="_CPPv3N16libmipflooding_c28scale_down_weighted_threadedEK8uint16_tK8uint16_tK7uint8_tPKfPK7uint8_tPfP7uint8_tKbK7uint8_tKbK7uint8_t"></span><span id="_CPPv2N16libmipflooding_c28scale_down_weighted_threadedEK8uint16_tK8uint16_tK7uint8_tPKfPK7uint8_tPfP7uint8_tKbK7uint8_tKbK7uint8_t"></span><span id="libmipflooding_c::scale_down_weighted_threaded__uint16_tC.uint16_tC.uint8_tC.floatCP.uint8_tCP.floatP.uint8_tP.bC.uint8_tC.bC.uint8_tC"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="pre">scale</span><span class="pre">_down</span><span class="pre">_weighted</span><span class="pre">_threaded()</span></span><a class="headerlink reference internal" href="#_CPPv4N16libmipflooding_c28scale_down_weighted_threadedEK8uint16_tK8uint16_tK7uint8_tPKfPK7uint8_tPfP7uint8_tKbK7uint8_tKbK7uint8_t" title="libmipflooding_c::scale_down_weighted_threaded"><span class="pre"></span></a></dt>
<dd><p class="brief">Scale down mip level (threaded version) </p>
<p>Input mip level and mask are scaled down to half their size, using the mask-weighted average for the mip, and a threshold for the mask (i.e. if any of the 4 mask pixels to be scaled is 1, the scaled pixel becomes 1).</p>
<p>The last image channel can optionally be scaled unweighted (regular box filtering). This can be useful when e.g. the alpha channel should reflect the average opacity, as opposed to becoming 1.0f through weighted scaling in cases where the alpha channel is identical to the coverage mask.</p>
<p>Use this function in a loop after <a class="reference internal" href="#_CPPv4N16libmipflooding_c31convert_and_scale_down_weightedEK8uint16_tK8uint16_tK7uint8_tPKvK13LMF_DATA_TYPEPKvK13LMF_DATA_TYPEPfP7uint8_tKfKbKbK7uint8_tKbK8uint16_t" title="libmipflooding_c::convert_and_scale_down_weighted">convert_and_scale_down_weighted()</a> to generate the remaining mip levels.</p>
<dl class="parameters field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="parameter-description field-list simple">
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint16_t</span><span class="w"> </span><span class="n sig-param">output_width</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Output mip level width in pixels (must be power of 2) </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint16_t</span><span class="w"> </span><span class="n sig-param">output_height</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Output mip level height in pixels (must be power of 2) </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint8_t</span><span class="w"> </span><span class="n sig-param">channel_stride</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Number of total channels in image data </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt float">float</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">input_image</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Pointer to input mip level, float* </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint8_t</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">input_mask</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Pointer to input mip mask, uint8_t* </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="kt float">float</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">output_image</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Pointer to pre-allocated output mip level, float* </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="kt int">uint8_t</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">output_mask</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Pointer to pre-allocated output mip mask, uint8_t* </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt bool">bool</span><span class="w"> </span><span class="n sig-param">is_normal_map</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>(optional) Perform processing for normal maps. Will re-normalize vectors to unit length at the moment, Slerp is planned. </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint8_t</span><span class="w"> </span><span class="n sig-param">channel_mask</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>(optional) Bit mask of channels to process, 0 = all channels. You can use <a class="reference internal" href="helper-functions.html#_CPPv4N16libmipflooding_c23channel_mask_from_arrayEPKbK7uint8_t" title="libmipflooding_c::channel_mask_from_array">channel_mask_from_array()</a> to generate a mask from an array of booleans. </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt bool">bool</span><span class="w"> </span><span class="n sig-param">scale_alpha_unweighted</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">false</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>(optional) Scale the last channel without coverage weighting? i.e. regular box filtering </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint8_t</span><span class="w"> </span><span class="n sig-param">max_threads</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span></p>
<span class="colon">:</span></dt>
<dd class="field-odd"><p>(optional) Number of threads to use. 0 = auto (half of available threads, which amounts to number of hardware cores for machines with SMT/HyperThreading) </p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N16libmipflooding_c12composite_upEK8uint16_tK8uint16_tK7uint8_tPKfPfPK7uint8_tK7uint8_tK8uint16_t">
<span id="_CPPv3N16libmipflooding_c12composite_upEK8uint16_tK8uint16_tK7uint8_tPKfPfPK7uint8_tK7uint8_tK8uint16_t"></span><span id="_CPPv2N16libmipflooding_c12composite_upEK8uint16_tK8uint16_tK7uint8_tPKfPfPK7uint8_tK7uint8_tK8uint16_t"></span><span id="libmipflooding_c::composite_up__uint16_tC.uint16_tC.uint8_tC.floatCP.floatP.uint8_tCP.uint8_tC.uint16_tC"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="pre">composite</span><span class="pre">_up()</span></span><a class="headerlink reference internal" href="#_CPPv4N16libmipflooding_c12composite_upEK8uint16_tK8uint16_tK7uint8_tPKfPfPK7uint8_tK7uint8_tK8uint16_t" title="libmipflooding_c::composite_up"><span class="pre"></span></a></dt>
<dd><p class="brief">Composite mip levels (small to large) </p>
<p>The smaller (“input”) mip is scaled up using nearest neighbor filtering and composited into the larger mip (“output”). This fills/”floods” areas outside the coverage mask.</p>
<p>Use this in a loop, smallest to largest mips, after generating the mip levels using <a class="reference internal" href="#_CPPv4N16libmipflooding_c19scale_down_weightedEK8uint16_tK8uint16_tK7uint8_tPKfPK7uint8_tPfP7uint8_tKbK7uint8_tKbK8uint16_t" title="libmipflooding_c::scale_down_weighted">scale_down_weighted()</a>.</p>
<dl class="parameters field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="parameter-description field-list simple">
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint16_t</span><span class="w"> </span><span class="n sig-param">input_width</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Width in pixels of the smaller mip (must be power of 2). </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint16_t</span><span class="w"> </span><span class="n sig-param">input_height_or_end_row</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Height in pixels of the smaller mip (must be power of 2), or end row for partial processing. </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint8_t</span><span class="w"> </span><span class="n sig-param">channel_stride</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Number of total channels in image data </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt float">float</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">input_image</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Pointer to smaller mip, float* </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="kt float">float</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">output_image</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Pointer to larger mip (output), float* </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint8_t</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">output_mask</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Pointer to larger mip mask, uint8_t* </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint8_t</span><span class="w"> </span><span class="n sig-param">channel_mask</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>(optional) Bit mask of channels to process, 0 = all channels. You can use <a class="reference internal" href="helper-functions.html#_CPPv4N16libmipflooding_c23channel_mask_from_arrayEPKbK7uint8_t" title="libmipflooding_c::channel_mask_from_array">channel_mask_from_array()</a> to generate a mask from an array of booleans. </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint16_t</span><span class="w"> </span><span class="n sig-param">start_row</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span></p>
<span class="colon">:</span></dt>
<dd class="field-even"><p>(optional) Start row for partial processing </p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N16libmipflooding_c21composite_up_threadedEK8uint16_tK8uint16_tK7uint8_tPKfPfPK7uint8_tK7uint8_tK7uint8_t">
<span id="_CPPv3N16libmipflooding_c21composite_up_threadedEK8uint16_tK8uint16_tK7uint8_tPKfPfPK7uint8_tK7uint8_tK7uint8_t"></span><span id="_CPPv2N16libmipflooding_c21composite_up_threadedEK8uint16_tK8uint16_tK7uint8_tPKfPfPK7uint8_tK7uint8_tK7uint8_t"></span><span id="libmipflooding_c::composite_up_threaded__uint16_tC.uint16_tC.uint8_tC.floatCP.floatP.uint8_tCP.uint8_tC.uint8_tC"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="pre">composite</span><span class="pre">_up</span><span class="pre">_threaded()</span></span><a class="headerlink reference internal" href="#_CPPv4N16libmipflooding_c21composite_up_threadedEK8uint16_tK8uint16_tK7uint8_tPKfPfPK7uint8_tK7uint8_tK7uint8_t" title="libmipflooding_c::composite_up_threaded"><span class="pre"></span></a></dt>
<dd><p class="brief">Composite mip levels (small to large) (threaded version) </p>
<p>The smaller (“input”) mip is scaled up using nearest neighbor filtering and composited into the larger mip (“output”). This fills/”floods” areas outside the coverage mask.</p>
<p>Use this in a loop, smallest to largest mips, after generating the mip levels using <a class="reference internal" href="#_CPPv4N16libmipflooding_c19scale_down_weightedEK8uint16_tK8uint16_tK7uint8_tPKfPK7uint8_tPfP7uint8_tKbK7uint8_tKbK8uint16_t" title="libmipflooding_c::scale_down_weighted">scale_down_weighted()</a>.</p>
<dl class="parameters field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="parameter-description field-list simple">
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint16_t</span><span class="w"> </span><span class="n sig-param">input_width</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Width in pixels of the smaller mip (must be power of 2). </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint16_t</span><span class="w"> </span><span class="n sig-param">input_height</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Height in pixels of the smaller mip (must be power of 2) </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint8_t</span><span class="w"> </span><span class="n sig-param">channel_stride</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Number of total channels in image data </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt float">float</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">input_image</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Pointer to smaller mip, float* </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="kt float">float</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">output_image</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Pointer to larger mip (output), float* </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint8_t</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">output_mask</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Pointer to larger mip mask, uint8_t* </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint8_t</span><span class="w"> </span><span class="n sig-param">channel_mask</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>(optional) Bit mask of channels to process, 0 = all channels. You can use <a class="reference internal" href="helper-functions.html#_CPPv4N16libmipflooding_c23channel_mask_from_arrayEPKbK7uint8_t" title="libmipflooding_c::channel_mask_from_array">channel_mask_from_array()</a> to generate a mask from an array of booleans. </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint8_t</span><span class="w"> </span><span class="n sig-param">max_threads</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span></p>
<span class="colon">:</span></dt>
<dd class="field-even"><p>(optional) Number of threads to use. 0 = auto (half of available threads, which amounts to number of hardware cores for machines with SMT/HyperThreading) </p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N16libmipflooding_c27final_composite_and_convertEK8uint16_tK8uint16_tK7uint8_tPKfPvK13LMF_DATA_TYPEPKvK13LMF_DATA_TYPEKfKbK7uint8_tK8uint16_t">
<span id="_CPPv3N16libmipflooding_c27final_composite_and_convertEK8uint16_tK8uint16_tK7uint8_tPKfPvK13LMF_DATA_TYPEPKvK13LMF_DATA_TYPEKfKbK7uint8_tK8uint16_t"></span><span id="_CPPv2N16libmipflooding_c27final_composite_and_convertEK8uint16_tK8uint16_tK7uint8_tPKfPvK13LMF_DATA_TYPEPKvK13LMF_DATA_TYPEKfKbK7uint8_tK8uint16_t"></span><span id="libmipflooding_c::final_composite_and_convert__uint16_tC.uint16_tC.uint8_tC.floatCP.voidP.LMF_DATA_TYPEC.voidCP.LMF_DATA_TYPEC.floatC.bC.uint8_tC.uint16_tC"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="pre">final</span><span class="pre">_composite</span><span class="pre">_and</span><span class="pre">_convert()</span></span><a class="headerlink reference internal" href="#_CPPv4N16libmipflooding_c27final_composite_and_convertEK8uint16_tK8uint16_tK7uint8_tPKfPvK13LMF_DATA_TYPEPKvK13LMF_DATA_TYPEKfKbK7uint8_tK8uint16_t" title="libmipflooding_c::final_composite_and_convert"><span class="pre"></span></a></dt>
<dd><p class="brief">Composite largest mip with original image. </p>
<p>The largest (“input”) mip is scaled up using nearest neighbor filtering, converted into the output format, and composited into the original image.</p>
<p>This fills/”floods” areas outside the coverage mask.</p>
<p>If no mask is provided (nullptr), the last color channel of the output image is used as the mask (e.g. “A” for an RGBA image). The mask is initially processed using the coverage_threshold parameter, which defaults to 0.999f (anything above 0.999f becomes 1, all other values become 0).</p>
<p>Use this after compositing the mip levels using <a class="reference internal" href="#_CPPv4N16libmipflooding_c12composite_upEK8uint16_tK8uint16_tK7uint8_tPKfPfPK7uint8_tK7uint8_tK8uint16_t" title="libmipflooding_c::composite_up">composite_up()</a>.</p>
<p>Set a custom channel mask if you want to preserve any of the original image’s channels, e.g. the alpha channel in an RGBA image.</p>
<dl class="parameters field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="parameter-description field-list simple">
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint16_t</span><span class="w"> </span><span class="n sig-param">input_width</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Width in pixels of the largest mip (must be power of 2, and half the width of the original image) </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint16_t</span><span class="w"> </span><span class="n sig-param">input_height_or_end_row</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Height in pixels of the largest mip (must be power of 2, and half the height of the original image), or end row for partial processing. </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint8_t</span><span class="w"> </span><span class="n sig-param">channel_stride</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Number of total channels in image data </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt float">float</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">input_image</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Pointer to largest mip, float* </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="kt">void</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">output_image</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Pointer to output image (expected to contain original image), void* </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><a class="reference internal" href="data-type.html#_CPPv4N16libmipflooding_c13LMF_DATA_TYPEE" title="libmipflooding_c::LMF_DATA_TYPE"><span class="n">LMF_DATA_TYPE</span></a><span class="w"> </span><span class="n sig-param">output_data_type</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Original image type as LMF_DATA_TYPE enum value </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">mask</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>(optional) Pointer to mask, void* or nullptr </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><a class="reference internal" href="data-type.html#_CPPv4N16libmipflooding_c13LMF_DATA_TYPEE" title="libmipflooding_c::LMF_DATA_TYPE"><span class="n">LMF_DATA_TYPE</span></a><span class="w"> </span><span class="n sig-param">mask_data_type</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Mask data type as LMF_DATA_TYPE enum value, ignored when mask pointer is nullptr </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt float">float</span><span class="w"> </span><span class="n sig-param">coverage_threshold</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0.999f</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>(optional) Threshold to use for binarizing the mask. Defaults to 0.999f. </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt bool">bool</span><span class="w"> </span><span class="n sig-param">convert_linear_to_srgb</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">false</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>(optional) Convert linear to sRGB </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint8_t</span><span class="w"> </span><span class="n sig-param">channel_mask</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>(optional) Bit mask of channels to process, 0 = all channels. You can use <a class="reference internal" href="helper-functions.html#_CPPv4N16libmipflooding_c23channel_mask_from_arrayEPKbK7uint8_t" title="libmipflooding_c::channel_mask_from_array">channel_mask_from_array()</a> to generate a mask from an array of booleans. </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint16_t</span><span class="w"> </span><span class="n sig-param">start_row</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span></p>
<span class="colon">:</span></dt>
<dd class="field-even"><p>(optional) Start row for partial processing </p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N16libmipflooding_c36final_composite_and_convert_threadedEK8uint16_tK8uint16_tK7uint8_tPKfPvK13LMF_DATA_TYPEPKvK13LMF_DATA_TYPEKfKbK7uint8_tK7uint8_t">
<span id="_CPPv3N16libmipflooding_c36final_composite_and_convert_threadedEK8uint16_tK8uint16_tK7uint8_tPKfPvK13LMF_DATA_TYPEPKvK13LMF_DATA_TYPEKfKbK7uint8_tK7uint8_t"></span><span id="_CPPv2N16libmipflooding_c36final_composite_and_convert_threadedEK8uint16_tK8uint16_tK7uint8_tPKfPvK13LMF_DATA_TYPEPKvK13LMF_DATA_TYPEKfKbK7uint8_tK7uint8_t"></span><span id="libmipflooding_c::final_composite_and_convert_threaded__uint16_tC.uint16_tC.uint8_tC.floatCP.voidP.LMF_DATA_TYPEC.voidCP.LMF_DATA_TYPEC.floatC.bC.uint8_tC.uint8_tC"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="pre">final</span><span class="pre">_composite</span><span class="pre">_and</span><span class="pre">_convert</span><span class="pre">_threaded()</span></span><a class="headerlink reference internal" href="#_CPPv4N16libmipflooding_c36final_composite_and_convert_threadedEK8uint16_tK8uint16_tK7uint8_tPKfPvK13LMF_DATA_TYPEPKvK13LMF_DATA_TYPEKfKbK7uint8_tK7uint8_t" title="libmipflooding_c::final_composite_and_convert_threaded"><span class="pre"></span></a></dt>
<dd><p class="brief">Composite largest mip with original image (threaded version) </p>
<p>The largest (“input”) mip is scaled up using nearest neighbor filtering, converted into the output format, and composited into the original image.</p>
<p>This fills/”floods” areas outside the coverage mask.</p>
<p>If no mask is provided (nullptr), the last color channel of the output image is used as the mask (e.g. “A” for an RGBA image). The mask is initially processed using the coverage_threshold parameter, which defaults to 0.999f (anything above 0.999f becomes 1, all other values become 0).</p>
<p>Use this after compositing the mip levels using <a class="reference internal" href="#_CPPv4N16libmipflooding_c12composite_upEK8uint16_tK8uint16_tK7uint8_tPKfPfPK7uint8_tK7uint8_tK8uint16_t" title="libmipflooding_c::composite_up">composite_up()</a>.</p>
<p>Set a custom channel mask if you want to preserve any of the original image’s channels, e.g. the alpha channel in an RGBA image.</p>
<dl class="parameters field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="parameter-description field-list simple">
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint16_t</span><span class="w"> </span><span class="n sig-param">input_width</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Width in pixels of the largest mip (must be power of 2, and half the width of the original image) </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint16_t</span><span class="w"> </span><span class="n sig-param">input_height</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Height in pixels of the largest mip (must be power of 2, and half the height of the original image) </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint8_t</span><span class="w"> </span><span class="n sig-param">channel_stride</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Number of total channels in image data </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt float">float</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">input_image</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Pointer to largest mip, float* </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="kt">void</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">output_image</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>Pointer to output image (expected to contain original image), void* </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><a class="reference internal" href="data-type.html#_CPPv4N16libmipflooding_c13LMF_DATA_TYPEE" title="libmipflooding_c::LMF_DATA_TYPE"><span class="n">LMF_DATA_TYPE</span></a><span class="w"> </span><span class="n sig-param">output_data_type</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Original image type as LMF_DATA_TYPE enum value </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="p pointer">*</span><span class="w"> </span><span class="n sig-param">mask</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>(optional) Pointer to mask, void* or nullptr </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><a class="reference internal" href="data-type.html#_CPPv4N16libmipflooding_c13LMF_DATA_TYPEE" title="libmipflooding_c::LMF_DATA_TYPE"><span class="n">LMF_DATA_TYPE</span></a><span class="w"> </span><span class="n sig-param">mask_data_type</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>Mask data type as LMF_DATA_TYPE enum value, ignored when mask pointer is nullptr </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt float">float</span><span class="w"> </span><span class="n sig-param">coverage_threshold</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0.999f</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>(optional) Threshold to use for binarizing the mask. Defaults to 0.999f. </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt bool">bool</span><span class="w"> </span><span class="n sig-param">convert_linear_to_srgb</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">false</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-even"><p>(optional) Convert linear to sRGB </p>
</dd>
<dt class="field-odd"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint8_t</span><span class="w"> </span><span class="n sig-param">channel_mask</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span></p>
<span class="p">,</span><span class="colon">:</span></dt>
<dd class="field-odd"><p>(optional) Bit mask of channels to process, 0 = all channels. You can use <a class="reference internal" href="helper-functions.html#_CPPv4N16libmipflooding_c23channel_mask_from_arrayEPKbK7uint8_t" title="libmipflooding_c::channel_mask_from_array">channel_mask_from_array()</a> to generate a mask from an array of booleans. </p>
</dd>
<dt class="field-even"><p class="function-parameter"><span class="k">const</span><span class="w"> </span><span class="kt int">uint8_t</span><span class="w"> </span><span class="n sig-param">max_threads</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span></p>
<span class="colon">:</span></dt>
<dd class="field-even"><p>(optional) Number of threads to use. 0 = auto (half of available threads, which amounts to number of hardware cores for machines with SMT/HyperThreading) </p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="core-functions.html" class="btn btn-neutral float-left" title="Core functions (C API)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="helper-functions.html" class="btn btn-neutral float-right" title="Helper functions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Jan Ortgies.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>